import { writeFileSync } from 'fs'
import * as path from 'path'
import buble from 'rollup-plugin-buble'
import typescript from 'rollup-plugin-typescript2'

/** HyperMD components */
const components = {
  "mode/hypermd": null, // exported nothing
  "addon/insert-file": "InsertFile",
  "addon/read-link": "ReadLink",
  "addon/hover": "Hover",
  "addon/click": "Click",
  "addon/paste": "Paste",
  "addon/mode-loader": "ModeLoader",
  "addon/cursor-debounce": "CursorDebounce",
}

/** Third-party libs */
const globalNames = {
  codemirror: "CodeMirror",
  marked: "marked",
  mathjax: "MathJax", // not really avaliable though
  hypermd: "HyperMD",
}

const external_tester = id_or_FilePath => {
  return id_or_FilePath in globalNames || !/^[\.\/]|^\w\:|\.ts$/.test(id_or_FilePath)
}

/**
 * rollup.js messes up the module path.
 * here we do it right.
 *
 * @param {string} sourcePath importer file fullPath
 * @param {string} id         importee file fullPath
 * @returns {string} relative path that works in output code
 */
const fix_core_path_in_single_file = function (sourcePath, id) {
  if (!path.isAbsolute(id)) return id // external libs

  if (/\bcore[\\\/]/.test(id)) {
    // ./src/core.js doesnot exists.
    // but ./core.js does
    id = path.resolve("./src/core")
  }

  var srcdir = path.dirname(sourcePath)
  var dstdir = path.dirname(id)

  // substr() is a workaround on Windows
  // https://github.com/nodejs/node/issues/17413
  if (/win/i.test(process.platform)) {
    srcdir = srcdir.substr(3)
    dstdir = dstdir.substr(3)
  }

  var reldir = path.relative(srcdir, dstdir)
  if (!reldir) reldir = "./"
  else reldir = reldir.replace(/\\/g, '/') + "/"

  var tmp = reldir + path.basename(id)
  return tmp
}

const the_plugins = [
  typescript(),
  buble({
    namedFunctionExpressions: false,
    transforms: {
      dangerousForOf: true,   // simplify `for (let i=0;i...)` to `for (let it of arr)`
    }
  })
]

var configs = [
  // Core
  {
    input: "./src/core.ts",
    external: external_tester,
    output: {
      file: './core.js',
      format: 'umd',
      name: "HyperMD",
      globals: globalNames,
    },
    plugins: the_plugins
  },
]

var ai1_imports = []
var ai1_exports = []

// compile every addon

for (const id in components) {
  const inputFullPath = path.resolve("./src/" + id + ".ts")
  var configItem = {
    input: "./src/" + id + ".ts",
    external: req_id => (req_id.indexOf(id) === -1),  // everything is external except itself!
    output: {
      file: "./" + id + ".js",
      format: "umd",
      paths: fix_core_path_in_single_file,
      globals: globalNames,
      paths: id => fix_core_path_in_single_file(inputFullPath, id),
    },
    plugins: the_plugins
  }

  const export_as = components[id]
  if (export_as) {
    configItem.output.name = "HyperMD." + export_as
    ai1_exports.push(export_as)
    ai1_imports.push(`import * as ${export_as} from "./${id}"`)
  } else {
    ai1_imports.push(`import "./${id}"`)
  }

  configs.push(configItem)
}

// generate all-in-one bundle file

writeFileSync("./src/ai1.ts", `// All in one HyperMD bundle!
//
// **DO NOT EDIT!** This file is generated by rollup.config.js
//

export * from "./core"

${ai1_imports.join("\n")}

${ai1_exports.length ? ("export { " + ai1_exports.join(", ") + " }") : ("// No more exports")}
`)

// if not watch mode, build the all-in-one bundle

if (process.argv.indexOf("-w") === -1) {
  configs.push({
    input: "./src/ai1.ts",
    external: external_tester,
    output: {
      file: './lib/hypermd_ai1.js',
      format: 'umd',
      name: "HyperMD",
      globals: globalNames,
    },
    plugins: the_plugins
  })
}

export default configs
