import * as ts from "typescript"
import { sys, forEachChild, Node, SyntaxKind } from "typescript"
import * as path from "path"
import { commandLine, program, srcPath } from "./base"
import { isExported, getNamedDeclarations } from "./tsUtil";
import { makeComponentLink, makeTypeString, makeDescription } from "./genUtils";

const config = require("../HyperMD.config")

export interface AddonInfo {
  name: string, // "addon/foobar"
  brief_description: string, // "One sentence introducing Foobar"
  description: string, // leadingComments, including brief_description

  Options: InterfaceProperty[],
}

export interface InterfaceProperty {
  name: string,
  type: string,
  description: string,
}

export interface EditorOptionItem extends InterfaceProperty {
  addon: AddonInfo,
}

export function populateInterfaceProperties(src: ts.InterfaceDeclaration, dst: InterfaceProperty[], sf: ts.SourceFile, postProcess?: (it: InterfaceProperty) => boolean) {
  forEachChild(src, (node) => {
    if (!ts.isPropertySignature(node)) return

    let it: InterfaceProperty = {
      name: node.name.getText(sf),
      description: makeDescription(node, sf),
      type: makeTypeString(node.type, sf),
    }

    if (postProcess && !postProcess(it)) return

    dst.push(it)
  })
}

/**
 * Scan all addon
 */
export function make(): string {
  var addonDescription = new Map<string, string>()
  var optionItems = [] as EditorOptionItem[]

  //#region [phase #1] scan all addon files ---------------------------------------------------------

  for (const compFileName in config.components) {
    if (!/^addon\//.test(compFileName)) continue

    const compFilePath = path.join(srcPath, compFileName + ".ts")
    const sf = program.getSourceFile(compFilePath)
    const declsMap = getNamedDeclarations(sf)

    var addon: AddonInfo = {
      name: compFileName,
      Options: [],
      description: "",
      brief_description: sf.text.match(/^\s*(?:\/\/|\/?\*+)\s+DESCRIPTION:\s*(.+)$/m)[1],
    }

    var currentNameSpace = "" // with "global." name. If is empty, means current module context

    function visitor(node: Node) {
      if (ts.isModuleDeclaration(node)) {
        // change `currentNameSpace` if needed

        let name = node.name.text
        let oldNameSpace = currentNameSpace

        if (!currentNameSpace) currentNameSpace = "global"
        if (name != "global") currentNameSpace += "." + name

        forEachChild(node, visitor)

        currentNameSpace = oldNameSpace
        return
      }

      if (ts.isInterfaceDeclaration(node)) {
        if (!currentNameSpace && !isExported(node)) return

        let name = node.name.text

        if (currentNameSpace == "") {
          if (name == 'Options') populateInterfaceProperties(node, addon.Options, sf)
        }

        if (currentNameSpace == "global.HyperMD") {
          if (name == 'EditorConfiguration') {
            populateInterfaceProperties(node, optionItems, sf, (it: EditorOptionItem) => {
              it.addon = addon
              it.type = it.type.replace(/Partial\<\[(\w+)\][^\>]+\>/, "`Partial<$1>`")
              it.description = it.description.replace(/^/gm, "> ")
              return true
            })
          }
        }
      }

      forEachChild(node, visitor)
    }
    forEachChild(sf, visitor)
  }

  //#endregion

  var result = [
    "# HyperMD Configurations",
    "> This documentation is automatically generated by *dev/docgen/configurations.md.ts* from addons' source files"
  ]

  //#region [phase #2] make the result      ---------------------------------------------------------

  { // editor property table
    let tableLines = [
      "| Name | Addon | Addon Description |",
      "| ---- | ---- | ---- |",
    ]
    for (const opt of optionItems) {
      tableLines.push(`| ${opt.name} | ${makeComponentLink(opt.addon.name)} | ${opt.addon.brief_description} |`)
    }
    result.push(tableLines.join("\n"))
  }

  for (const opt of optionItems) {
    const addon = opt.addon

    let appendix = [] as string[]
    let sectionLines = [
      "\n\n\n",
      `## ${opt.name}`,
      ``,
      `ðŸ“¦ **Provided by ${makeComponentLink(addon.name)}** : ${addon.brief_description}`,
      `ðŸŽ¨ **Type** : ${opt.type}`,
      ``,
      opt.description,
    ]

    if (addon.Options.length) {
      sectionLines.push(
        "",
        "***Options** and **Partial\\<Options>** is an object and may contains:*",
        "",
        "| Name | Type | Description |",
        "| ---- | ---- | ---- |",
      )
      for (const p of addon.Options) {
        let description = p.description
        let multiline = description.includes("\n")
        sectionLines.push(`| ${p.name} | ${multiline ? " " : p.type} | ${multiline ? "*(See below)*" : description} |`)
        if (multiline) {
          appendix.push([
            `### ${p.name}`,
            ``,
            `ðŸŽ¨ **Type** : ${p.type}`,
            ``,
            description.replace(/^/gm, "> "),
          ].join("\n"))
        }
      }
    }

    result.push(sectionLines.join("\n"))
    for (const it of appendix) result.push(it)
  }

  //#endregion

  return result.join("\n\n")
}

if (require.main === module) {
  console.log(make())
}
